# Курс по JavaScript: конспект

Используется для создания функционала клиентской части (без перезагрузки страницы, то есть без отправки данных на сервер)

###### комментарии в js: 

```
//однострочный 
```

или 
```
/* многострочный */
```

### Некоторые html-теги

##### noscript

Тег "noscript" выводится только в том случае, если js не включён у конечного пользователя.

В браузерах js обычно включён по уиолчанию.

##### script

За счёт этого тега мы можем либо подключить к html-странице какой-то сторонний js-файл, либо прямо внутри тега script прописать какой-то js-код, который будет ввыполнять в пределах этой html-страницы. 

Тег script можно прописывать где угодно, но лучше это делать перед закрывающим тегом body (так как страница прогружается сверху вниз; тогда сначала прогрузится находящийся вверху страницы html-код, а потом уже начнут прогружаться скрипты, но пока они грузятся, уже будет загружен основной вид сайта)

Тегов script может быть больше одного; если на странице несколько таких тегов, то они будут выполнться по порядку сверху вниз.

Обычно js пишут в отдельном файле.

Если мы пишем js-код в отдельном js-файле, то тег script не нужен; он только для вставки js-кода в html-файл.

Подключение js-файла через script: 

```
<script src="путь к файлу"></script>
```

Если вдруг мы создали js-файл, прописали внутри него код, код рабочий, но почему-то не выполняется, то, возможно, файл попал в кеш;тогда можно нажать правой кнопкой мыши на значок обновления страницы и выбрать "очистка кеша и жёсткая перезагрузка".

## Вывод информации на страницу

Устаревший вариант: 

обращаемся к объекту document и вызываем его метод:

```
document.write("text");
```

обычно этот способ не применяется, так как не позволяет вывести информацию внутри определённого html-тега; он выводит её сразу после тега script (видно, если в браузере открыть код страницы).

Метод document.write() следует использовать только для тестирования.

## Вывод информации в консоль

(речь о консоли разработчика в браузере, которая открывается с помощью "посмотреть код страницы")

Синтаксис:

```
console.log("text");
//или
console.info("ещё один текст");
//оба способа дают один и тот же результат
```

Это нужно, например, для каких-то проверок, чтобы посмотреть, что внутри какого-то объекта, или посмотреть, как что-то работает, но не выводить это на саму страницу.

Вывести в консоль сообщение об ошибке:

```
console.error("текст");
```
этот текст будет оформлен как сообщение об ошибке

Вывести в консоль сообщение, которое будет оформлено как предупреждение (жёлтым цветом + значок предупреждения):

```
console.warn("текст");
```

## Переменные и типы данных

Переменная - это ячейка в памяти компьютера, содержащая какие-либо данные.

Создание переменной:

```
var название;
```

Присвоение значений:

```
var a;
a = 55;
//или:
var b = 100;
```

Действия с переменными - как и везде.

Результат вывода 

```
console.log("Переменная: " + a);
``` 
это объединение строк.

Результат вывода 

```
a = 55;
var b = 100;

console.log(a+b);
``` 
это вывод суммы чисел (155).

Переменной также можно присвоить сначала одно значение, а потом другое - переопределить.

#### Константы

Константа - переменная, которую нельзя переопределить.

Создание константы:

```
const название = значение;
```
Попытка присвоить ей другое значение вызовет ошибку.

##### !

Оператор идентификации переменной var устарел, однако есть некоторые функции, которые пока что не работают с оператором let. Если нужно вначале использовать какую-либо переменную, а затем только объявить её, то потребуется использование var (использование let выдаст reference error (ошибку ссылки)). Также есть отличие в области видимости переменной. В случае с let, если мы будем использовать конструкцию for, while, то при let переменная создастся исключительно на время действия цикла, при var область видимости увеличится, и переменная будет глобальная, а значит, её можно будет использовать за пределами цикла.

Переменная, объявленная через var, видна везде в функции.

Переменная, объявленная через let, видна только в рамках блока, в котором объявлена.

В таком случае, если, например, вне цикла через let объявлена переменная, а внутри (также через let) объявлена переменная с таким же названием, то действия, произведённые над переменной в цикле, не повлияют на значение переменной, находящейся вне его; и наоборот.

### Математические действия

Вывести результат метематического действия:

```
//1 способ:
let res = w - a;
console.log(res);

//2 способ:
console.log("Res:" + (w - a));

//Если бы мы вывели без скобок, то есть вот так:
console.log("Res:" + w - a);
//то получили бы ошибку

//следующая операция:
console.log("Res: " + per1 + per2);
//выведет нам не сумму переменных, а просто сами переменные, записанные в строку друг за другом
```

С остальными математическими действиями аналогично; базовые математические действия - как и в других языках.

Сокращённые формы математических действий (то есть мат действия, совершённые над одной переменной) - аналогично остальным языкам:

```
// это:
let per = 0;
per = per + 5;
// аналогично этому:
let per = 0;
per += 5;
```

#### встроенная функция Number()

позваоляет сделать число из строки, содержащей число.

То есть, если у нас есть строка:

```
let str = "2222";
```

То, чтобы сделать из неё число, используется:

```
Number("2222");
```

Применение:

```
let str = "22222";

let str1 = "33";

let str2 = Number("22222");

let str3 = Number(str);

//выведет как строку, просто слепив цифры, потому что здесь мы не применяли Number():
console.log("bababa" + str + str1);

//выведет как строку, просто слепив цифры, потому что мы применили Number(), но не поставили скобки:
console.log("bababa" + str2 + str3);

//выведет как строку, просто слепив цифры, потому что здесь мы, хоть и поставили скобки, но не применяли Number():
console.log("bababa" + (str + str1));

//Выведет сумму значений переменных, так как мы применили Number() и поставили скобки:
console.log("bababa" + (str2 + str3));
```

#### встроенный объект Math

Некоторые его функции:

```
console.log(Math.E); //вывод числа e
console.log(Math.sin(0)); 
console.log(Math.min(2, 4, 7, 1, -4, 100));
console.log(Math.max(2, 4, 7, 1, -4, 100));
```

## Условные операторы

Операторы if, else, else if, switch-case - как и в других языках; 

Но с одной особенностью: 

```
//из-за нестрогой типизации при сравнении таких переменных:
var f = "15";
var ff = 15;

//здесь они будут равны:
if (f == ff) {
    ...
}

//а здесь (при проверке также по типу) - нет:
if (f === ff) {
    ...
}
```

Также, если мы будем сравнивать число со строкой, содржащей число, они буду сравниваться как обычные числа.

#### Проверка сразу нескольких условий:

Условия пишутся в одной скобке:

```
if (f > fff || f === ff) {
    ...
}

if (f > fff && f === ff) {
    ...
}
```

Проверка для типа bool:

```
if (per == true) {
    ...
}

//или кратко:

if(per) {
    ...
}
```

## Массивы

Варианты способов создания:

```
var mass = new Array(100, 200, 300);
var mass2 = [100, 200, 300];
let arr = new Array(100, 200, 300);
let arr2 = [100, 200, 300];
```

При выводе созданных таких образом массивов не будет видно никакой разницы (разница лишь в области видимости let и var)

Создание многомерного массива:

```
let mass = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
```
(или var)

Вывести массив можно как через цикл, так и через console.log (это касается и одномерных, и многомерных массивов).

Функция, возвращающая размер массива - length;

Применяется к массиву через точку: 
```
arr.length;
```
Скобки у length не нужны.

## Циклы

Циклы for, while, dowhile - как и в других языках, за исключением одной особенности - счётчик цикла инициализируется так же, как инициализируются переменные в js.

Пример:

```
for (let i = 0; i < 4; i++) {
    console.log(mass[i]);
}
```
(или var)

Примеры цикла while:

```
let j = 17;
while(j > 10) {
    console.log(j);
    j--;
}

let m = 177;
while(m > 18) {
    console.log(m);
    m-=17;
}
```
(или var)

Краткая запись для типа bool:

```
while (per == true)

// это то же условие, что и:

while (per)

// но если мы ничего не делаем с переменной per, то цикл будет бесконечным; лучше так не делать
```

dowhile - обязательно будет выполнена одна итерация цикла, а потом произойдёт проверка; делается как и в других языках. Пример:

```
let n = 500;
do {
    console.log(n);
} while (n >= 1000);
```

#### Некоторые операторы для циклов:

break; - выход из цикла;

Обычно пишется внутри цикла вместе с if, то есть: если что-то, то цикл завершается.

Код, находящийся в теле цикла после break, не выполнится.

continue; - пропуск итерации;

Обычно пишется внутри цикла вместе с if, то есть: если что-то, то цикл завершается. 

код, находящийся в теле цикла после continue, не выполнится на текущей итерации, и произойдёт сразу в начало следующей итерации.

## Всплывающие окна

Создаются с помощью встроенных функций.

Этим окнам нельзя добавить стили, они устанавливаются браузером; чтобы добавить стили, нужно делать их самостоятельно с нуля: селать скрытый блок, который становится видимым при нажатии.

+ Окно, содержащее какую-либо информацию и кнопку "ок":

```
alert("текст");
```

Появляется в браузере при открытии страницы. Можно также сделать так, чтобы оно всплывало после какого-то действия, например, нажатия на кнопку.

Всплывающих окон может быть больше одного (сколько угодно).

+ Окно, содержащее две кнопки: "ок" и "отмена"

```
confirm("текст");
```

Результат выбора (ок или отмена) можно поместить в переменую и вывести в консоли (можно и не выводить):

```
let data = confirm("текст");
console.log(data);
```

Если пользователь выбрал "ок", то data = true, если "отмена", то data = false.

+ Получение данных от пользователя через всплывающее окно:

```
prompt("введите что-то", "что-то");
```

Здесь "введите что-то" - сообщение для пользователя, "что-то" - placeholder в поле ввода (плейсхолдеру не нужны кавычки, они тут, потому что тип данных - строка).

Сохранение введённых пользователем данных в переменную + вывод её в консоль:

```
let data2 = prompt("введите что-то", "что-то");
console.log(data2);
```

## Функции

Создаются, вызываются, принимают параметры - как и в других языках. Примеры в train файле.

Важный пример:
```
// возвращение значений из функции:

function summass2 (mass2) {
    let sum2 = 0;
    for (var i = 0; i < mass2.length; i++) {
        sum2 += mass2[i];
    }
    return sum2;
} //не вывели на экран сразу, а вернули результат

let sum2res = summass2(mass2); //засунули результат в переменную
console.log(sum2res); //вывели переменную
```

##### !

Если мы создадим переменную вне функции, то она будет глобальная, и мы сможем обратиться к ней как внутри функции, так и вне её; если мы создадим переменную внутри функции, то она будет локальная, и мы сможем обращаться к ней внутри функции, но не сможем вне.

## События

События - это действия пользователя. Обработчик событий производит какие-то действия (например, вызов функции) после того, как событие произошло.

Основной способ добавить обработчик событий - атрибуты к html-тегам.

### Некоторые атрибуты для обработки событий:

#### атрибут onclick

```
<button onclick="alert('текст')"> текст на кнопке </button>
```

Внутри этого атрибута прописываем какой-то js-код или функцию, которая будет вызвана после нажатия. Здесь это встроенная функция alert, но может быть и не встроенная. 

Это удобно для малого количества кода.

Если кода много, можно его весь прописать в какой-то функции в своём основном js-коде, а здесь просто вызвать эту функцию. 

Атрибут onclick можно добавлять к любым html-тегам, отображающим что-то для пользователя, не обязательно только к кнопкам.

#### атрибут ondblclick

(on double click)

Вызывает функцию при двойном нажатии на тег.

#### атрибут onmouseover

Вызывает функцию при наведении курсора мыши на тег.

#### атрибут onmouseout

Вызывает функцию не при наведении курсора мыши на тег, а после того, как курсор с тега убрали.

#### атрибут onload

Вызывает функцию, когда тег полностью загружен.

Обычно применяется к тегу body => функция вызывается, когда страница полностью загружена.

### Подсчёт числа нажатий на кнопку

#### просто подсчёт: 

Для этого достаточно сделать кнопку, которая в атрибуте onclick вызывает функцию kolvo_nazhatiy():

```
<button onclick="kolvo_nazhatiy()"> кнопка </button>
```

В js-файле мы создадим глобальную переменную счётчика, и при каждом вызове функции просто увеличиваем её на единицу:

```
var sch = 0;

function kolvo_nazhatiy() {
    sch++;
}
```

(если бы мы создали локальную переменную внутри функции, счётчик всегда был бы равен 1 и не инкрементировался)

Также можно вывести результат в консоль:

```
function kolvo_nazhatiy() {
    sch++;
    console.log("вы нажали на кнопку " + sch + " раз(а)");
}
```

#### подсчёт с выводом значения счётчика на страницу:

Вызываемой в теге onclick функции при вызове передаём параметр this; то есть передаём ей этот самый объект (тег), в котором она вызывается:

```
<button onclick="kolvo_nazhatiy(this)"> кнопка </button>
```

Функция количества нажатий примет вид:

```
function kolvo_nazhatiy2(button) {
    sch++;
    button.innerHTML = "вы нажали на кнопку " + sch + " раз(а)";
}
```

Здесь button - это название, которое мы придумали для html-элемента, с кооторым работает функция (в данном случае для кнопки), оно может быть любым.

Потом мы обратились к этому html-элементу по его названию и вызвали метод innerHTML, который вставляет текст в html-элементы.

### Работа с HTML-объектом

В js-коде мы можем внутри функции, указанной в атрибуте onclick, обращаться к различным атрибутам этого объекта, и, например, выводить их значения в консоль:

```
console.log("onclick: " + element.onclick);
console.log("name: " + element.name)
```

#### работа с тегом input:

Если есть input-поле, в которое пользователь может что-то ввести, то мы можем вывести то, что вводит полльзователь, в консоль (и не только):

Так выглядит тег input в html-файле:

```
<input oninput="input(this)">введите что-то:
```

Так выглядит соответствующая js-функция:

```
function input(inp) {
    console.log(inp.value);
}
```
(на месте inp могло быть любое другое название)

value - встроенный метод, возвращающий то, что вводит пользователь.

Можно также прописывать какие-то действия в зависимости от того, что ввёл пользователь(если элемент.value == чему-то, то происходит то-то...)

##### Изменение стилей при нажатии

```
function kolvo_nazhatiy2(button) {
    // способ 1:
    button.style.background = "orange";
    button.style.color = "yellow";

    // способ 2:
    button.style.cssText = "font-size: 20px; color: yellow; background-color: orange";
}
```

Вторым способом мы в cssText можем прописывать стили так же, как прописывали бы их в обычном css-коде; здесь мы это делаем применительно к определённому html-объекту.

Два этих способа использовать одновременно не получится. Если применить оба сразу, то отобразится только результат второго. 

## Управление HTML и обработка форм на js

### Как найти тег по id

Пусть у нас на html-транице есть html-тег:

```
 <p id="blablabla">blablabla</p>
```

Чтобы обратиться к этому тегу по его id, используем встроенную функцию:

```
var blablabla = document.getElementById('blablabla');
```

document - это встроенный объект в js; с помощью него мы можем управлять всей DOM-структурой страницы; содержит различные методы.

ВАЖНО: тег script с подключением соответствующего js-файла должен находиться на странице ниже, чем тег, к которому мы пытаемся обратиться по id (а в идеале - после всего html-кода, пере закрытием тега body)

Теперь мы можем через точку обращаться к различным атрибутам этого тега, например, вывести их в консоль:

```
console.log(blablabla.id);
```

или добавить новый атрибут:

```
blablabla.title = "bebebe";
```
(до этого у тега с id blablabla не было атрибута title), 

или изменить стиль тега:

```
blablabla.style.cssText = "color: yellow; background-color: orange; font-size:17px";
```

(если бы мы не захотели писать свойства в cssText, а использовали свойство style и отдельные штуки для стилей через точку, то background-color мы бы записывали как backgroundColor)

Записать что-то внутрь объекта (это может быть как текст, так и html-код) можно через:

```
blablabla.innerHTML = "a<br>b<br>c";
```

Нам не обязательно создавать переменную, чтобы обратиться к объекту, найденному по id. Можно сделать так:

```
document.getElementById('какое-то_id').какая-то_функция;
```

Например:

```
document.getElementById('blablabla').innerHTML = "a<br>b<br>c<br>d";
```

При поиске по id нам возвращается один объект.

### Как найти тег по названию тега

При таком поиске нам возвращается массив (даже если будет найден всего один объект) => его нужно перебирать через цикл.

Пусть в html-файле есть несколько тегов span:

```
<span> bebebe </span>
<span> bububu </span>
<span> bababa </span>
```

Чтобы обратиться к элементам этого массива, создаём переменную, в которую помещаем массив html-объектов, которые мып олучаем с помощью метода getElementsByTagName; после этого работаем с мссивом как обычно, например:

```
let spans = document.getElementsByTagName('span');
for (let i = 0; i < spans.length; i++) {
    console.log(spans[i].innerHTML);
}
```

Метод innerHTML без параметров просто возвращает содержимое тега.

### Как найти тег по названию класса

Это делается через функцию getElementsByClassName('название_класса') аналогично предыдущему пункту.

### Обработка форм с помощью js

Происходит только на стороне клиента.

Создадим в html-файле форму:

```
<form id="main-form">
        <label for="name">имя:</label>
        <input type="text" name="name" id="name" placeholder="имя"><br><br>
        <label for="password">пароль:</label>
        <input type="password" name="pass" id="pass" placeholder="пароль"><br><br>
        <label for="repass">проверка пароля</label>
        <input type="password" name="repass" id="repass" placeholder="проверка пароля"><br><br>
        <span>пол:</span>
        <input type="radio" name="state" id="male" value="мужской">
        <label for="male">мужской</label>
        <input type="radio" name="state" id="female" value="женский">
        <label for="male">женский</label><br><br>
        <input type="button" name="submit" value="готово">
    </form>
```

Сделаем так, чтобы при нажатии на кнопку на стороне клиента происходила обработка форм (получение данных, валидация).

Для этого:
+ либо в качестве атрибута кнопки, имеющей тип button, прописываем атрибут onclick; 
+ либо в качестве атрибута формы, содержащей кнопку типа submit, прописываем onsubmit

Второй способ:

```
<form id="main-form" onsubmit="checkForm(this)">
        <label for="name">имя:</label>
        <input type="text" name="name" id="name" placeholder="имя"><br><br>
        <label for="password">пароль:</label>
        <input type="password" name="pass" id="pass" placeholder="пароль"><br><br>
        <label for="repass">проверка пароля</label>
        <input type="password" name="repass" id="repass" placeholder="проверка пароля"><br><br>
        <span>пол:</span>
        <input type="radio" name="state" id="male" value="мужской">
        <label for="male">мужской</label>
        <input type="radio" name="state" id="female" value="женский">
        <label for="male">женский</label><br><br>
        <input type="submit" name="submit" value="готово">
    </form>
```

В js-файле:
```
function checkForm(mainForm) {
    console.log("форма заполнена");
}
```

Если здесь не указать метод передачи данных, то по умолчанию будет использован get.

Так как тип кнопки - submit, то после каждого нажатия кнопки перезагружается страница. И если мы, например, после нажатия кнопки выводили какой-то текст, то он будет выведен, но потом сражу же исчезнет, так как страница обновится.

Как сделать, чтобы страница обновлялась не после каждого нажатия, а только при определённых условиях:

Страница перезагрузится, если функция вернёт значение true. Тогда сделаем так, чтобы она возвращала значение false:

```
function checkForm(mainForm) {
    console.log("форма заполнена");
    return false;
}
```

Чтобы это сработало, поменяем:

```
<form id="main-form" onsubmit="checkForm(this)" method="post">
```
на
```
<form id="main-form" onsubmit="return checkForm(this)" method="post">
```
Теперь страница не обновляется после нажатия на кнопку.

##### получение данных из формы:

Создадим переменные, в которые сохраним содержимое полей. Для этого есть 2 способа:

```
//1 способ:
let name = document.getElementById('name').value;

//2 способ: здесь мы обращаемся к форме по её названию, которое дали в функции, обрабатывающей форму (см. ранее), затем через точку обратились к полю формы по значению её атрибута name, а затем через точку получили value
let name = mainForm.name.value;
```

Валидация происходит посредством условных конструкций.

### Перенаправить на другую страницу после нажатия на кнопку:

Кнопка на html-странице:

```
<button onclick="anwind()"> кнопка </button>
```

Функция в js-файле:
```
function anwind(knopka) {
    window.location = 'index2.html';
}
```

### Обработчик событий eventListener

Работает без атрибутов, показывающих, после какого действия происходит что-то (то есть без onclick и подобных).

Берём форму, с которой работали ранее, и удаляем такой атрибут:

```
<form id="main-form" method="post">
        <label for="name">имя:</label>
        <input type="text" name="name" id="name" placeholder="имя"><br><br>
        <label for="password">пароль:</label>
        <input type="password" name="pass" id="pass" placeholder="пароль"><br><br>
        <label for="repass">проверка пароля</label>
        <input type="password" name="repass" id="repass" placeholder="проверка пароля"><br><br>
        <span>пол:</span>
        <input type="radio" name="state" id="male" value="мужской">
        <label for="male">мужской</label>
        <input type="radio" name="state" id="female" value="женский">
        <label for="male">женский</label><br><br>
        <input type="submit" name="submit" value="готово">
    </form>
```

В js-файле пишем:

```
document.getElementsById('main-form').addEventListener("submit", checkForm);
function checkForm() {
    let mainForm = document.getElementsById('main-form');
    console.log("форма заполнена");

    let name = mainForm.name.value;
    let password = mainForm.pass.value;
    let repass = mainForm.repass.value;
    let gender = mainForm.state.value;
    console.log(name + ", " + password + ", " + repass + ", " + gender)

    return false;
}
```

